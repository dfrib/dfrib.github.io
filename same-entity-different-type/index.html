<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <title>
    Same entity, different type? // [unfold] Bits of awareness
  </title>

  <link href="https://gmpg.org/xfn/11" rel="profile">
<meta http-equiv="content-type" content="text/html; charset=utf-8">


<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

<meta name="description" content="">
<meta name="keywords" content="">
<meta name="author" content="[David Friberg]">
<meta name="generator" content="Hugo 0.75.1" />


  <meta property="og:title" content="Same entity, different type?" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:locale" content="en_US" />
<meta property="og:url" content="https://dfrib.github.io/same-entity-different-type/" />


  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/base-min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/pure-min.css">
  
  
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/grids-responsive-min.css">
  
  

   
   <link rel="stylesheet" href="https://dfrib.github.io/css/redlounge.css">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  <link href='//fonts.googleapis.com/css?family=Raleway:400,200,100,700,300,500,600,800' rel='stylesheet' type='text/css'>
  <link href='//fonts.googleapis.com/css?family=Libre+Baskerville:400,700,400italic' rel='stylesheet' type='text/css'>

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://dfrib.github.io/touch-icon-144-precomposed.png">
  <link rel="shortcut icon" type="image/x-icon" href="https://dfrib.github.io/img/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="[unfold] Bits of awareness" />

  


  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/atom-one-dark.min.css">
  <link rel="stylesheet" href="https://dfrib.github.io/css/override.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script>
  <script
    charset="UTF-8"
    src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/lisp.min.js"></script>
  <script
    charset="UTF-8"
    src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/swift.min.js"></script>
  <script
    charset="UTF-8"
    src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cmake.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>


  

  

  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-179323449-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  
</head>

<body>
	

	<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
  <div class="header">
    

	

    <h1 class="brand-title">[unfold]</h1>
    <h2 class="brand-tagline">Bits of awareness</h2>

    <nav class="nav">
      <ul class="nav-list">
        
        
          <li class="nav-item"><span class="nav-item-separator">//</span><a href="https://dfrib.github.io/">Home</a></li>
        
          <li class="nav-item"><span class="nav-item-separator">//</span><a href="https://dfrib.github.io/categories/cplusplus">C&#43;&#43;</a></li>
        
          <li class="nav-item"><span class="nav-item-separator">//</span><a href="https://dfrib.github.io/categories/emacs">Emacs</a></li>
        
      </ul>
    </nav>

    
    <div class="social-buttons">
      
        
        <a href="https://github.com/dfrib" target="_blank"><i class ='fa fa-github'></i></a>
        
      
        
        <a href="https://www.linkedin.com/in/david-friberg-7642863a" target="_blank"><i class ='fa fa-linkedin'></i></a>
        
      
        
        <a href="https://stackoverflow.com/users/4573247/dfri?tab=profile" target="_blank"><i class ='fa fa-stack-overflow'></i></a>
        
      
      
    </div>
    

  </div>
</div>

	
	

    <div class="content pure-u-1 pure-u-md-3-4">
		<a name="top"></a>
		

		
			
		    
			
		    
		    
		    
	    
  		<section class="post">
            <h1 class="post-title">
              <a href="https://dfrib.github.io/same-entity-different-type/">Same entity, different type?</a>
            </h1>
            <h3 class="post-subtitle">
            	
            </h3>
            
            	
                
            	
            	
            
            	
            		
            		
            	
            

			
			
				<div class="post-categories">
				
					<a class="post-category post-category-cplusplus" href="https://dfrib.github.io/categories/cplusplus">cplusplus</a>
				
				</div>
			
            
				<div class="tags-list">
					<span class="dark-red">Tags</span><span class="decorative-marker">//</span>
					
	                <a class="post-tag post-tag-cpp" href="https://dfrib.github.io/tags/cpp">cpp</a>,
	                
	                <a class="post-tag post-tag-quiz" href="https://dfrib.github.io/tags/quiz">quiz</a>,
	                
				</div>
			

			

			

            <blockquote>
<p>Is(/are) there any scenario(s) where a name, which refers to an entity, actually
refers to a different types (whilst still referring to the same entity)
depending on context and/or scope? Or, to put it in another way, is(/are) there
any scenario(s) where the type of a named entity changes depending on context
and/or scope?</p>
</blockquote>
<p>where, as a hint, an <em>entity</em> is, as per <a href="https://timsong-cpp.github.io/cppwp/n4659/basic#3">{basic}/3</a>:</p>
<blockquote>
<p>[An entity is] a value, object, reference, function, enumerator, type, class
member, bit-field, template, template specialization, namespace, or parameter
pack.</p>
</blockquote>
<p>Note that we&rsquo;re not looking for cases where a given name (or, formally,
identifier) can refer to different entities due to e.g. overload resolution; it shall
refer to the same entity.</p>
<details>
<summary>
Same entity, different type
</summary>
<p class="details">
<p>The answer is <em>the enumerator</em> of an enumeration (we will refer to enumeration as its short name <em>enum</em>, henceforth).</p>
<p>As governed by <a href="https://timsong-cpp.github.io/cppwp/n4659/dcl.enum#5">{dcl.enum}/5</a> (<a href="https://timsong-cpp.github.io/cppwp/n4659/">N4659;
March 2017 post-Kona working draft/C++17 DIS</a>) [extract, <strong>emphasis</strong>  mine]:</p>
<blockquote>
<p><strong>Following the closing brace</strong> of an enum-specifier, <strong>each enumerator has the
type of its enumeration</strong>. If the underlying type is fixed, the type of each
enumerator <strong>prior to the closing brace is the underlying type</strong> [&hellip;]. If the
underlying type <strong>is not fixed</strong>, <strong>the type of each enumerator prior to the
closing brace</strong> is determined as follows:</p>
<ul>
<li>[&hellip;]</li>
</ul>
</blockquote>
<p>the type of an enumerator changes depending on whether its referred to from within the definition of the enum which defines it, or from outside of it.</p>
<p>Inside the definition of the enum (no matter if it is a scoped enum or not), the
type of an enumerator of the enum (ignoring some details in <a href="https://timsong-cpp.github.io/cppwp/n4659/dcl.enum#5.1">{dcl.enum}/5.1</a> and
<a href="https://timsong-cpp.github.io/cppwp/n4659/dcl.enum#5.3">{dcl.enum}/5.3</a> for enums where the underlying type is not fixed) is that
of the underlying type, whereas outside of the definition of the enum, the type
of the same enumerator is that of the enum itself.</p>
<p>We may show it in practice with an example, where we start by defining a trait
that wraps a type identity check (<code>std::is_same</code>) whilst forwarding a
<code>constexpr</code> value:</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000080">// util.h
</span><span style="color:#000080"></span><span style="color:#000080">#pragma once
</span><span style="color:#000080">#include</span> <span style="color:#000080">&lt;type_traits&gt;</span><span style="color:#000080">
</span><span style="color:#000080"></span>
<span style="color:#000080">// Forward a constexpr value whilst statically asserting
</span><span style="color:#000080">// type identity between the two type template parameters.
</span><span style="color:#000080"></span><span style="color:#cdcd00">template</span> <span style="color:#39c">&lt;</span><span style="color:#cdcd00">typename</span> T, <span style="color:#cdcd00">typename</span> U, <span style="color:#00cd00">int</span> VALUE<span style="color:#39c">&gt;</span>
<span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">is_same_and_value</span> {
    <span style="color:#cdcd00">static_assert</span>(std<span style="color:#39c">::</span>is_same_v<span style="color:#39c">&lt;</span>T, U<span style="color:#39c">&gt;</span>, <span style="color:#cd0000">&#34;&#34;</span>);
    <span style="color:#cdcd00">static</span> <span style="color:#cdcd00">constexpr</span> <span style="color:#00cd00">int</span> value <span style="color:#39c">=</span> VALUE;
};

<span style="color:#cdcd00">template</span> <span style="color:#39c">&lt;</span><span style="color:#cdcd00">typename</span> T, <span style="color:#cdcd00">typename</span> U, <span style="color:#00cd00">int</span> VALUE<span style="color:#39c">&gt;</span>
<span style="color:#cdcd00">constexpr</span> <span style="color:#00cd00">int</span> is_same_and_value_v <span style="color:#39c">=</span>
    is_same_and_value<span style="color:#39c">&lt;</span>T, U, VALUE<span style="color:#39c">&gt;::</span>value;
</code></pre></div><p>and thereafter make use of this trait to check the type identity of an
enumerator from within an enum definition whilst simultaneously initializing
another enumerator with a <code>constexpr</code> value.</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000080">#include</span> <span style="color:#000080">&lt;type_traits&gt;</span><span style="color:#000080">
</span><span style="color:#000080">#include</span> <span style="color:#000080">&#34;util.h&#34;</span><span style="color:#000080">
</span><span style="color:#000080"></span>
<span style="color:#cdcd00">enum</span> <span style="color:#cdcd00">class</span> <span style="color:#00cdcd">Foo</span><span style="color:#39c">:</span> <span style="color:#00cd00">int</span>;
<span style="color:#cdcd00">constexpr</span> Foo f <span style="color:#39c">=</span> <span style="color:#cdcd00">static_cast</span><span style="color:#39c">&lt;</span>Foo<span style="color:#39c">&gt;</span>(<span style="color:#cd00cd">0</span>);

<span style="color:#cdcd00">enum</span> <span style="color:#cdcd00">class</span> <span style="color:#00cdcd">Foo</span><span style="color:#39c">:</span> <span style="color:#00cd00">int</span> {
  A,
  <span style="color:#000080">// A (and other enumerators) are of the same type as the
</span><span style="color:#000080"></span>  <span style="color:#000080">// underlying type (&#39;int&#39;) within the scope of the enum definition.
</span><span style="display:block;width:100%;background-color:#191919"><span style="color:#000080"></span>  B <span style="color:#39c">=</span> is_same_and_value_v<span style="color:#39c">&lt;</span><span style="color:#cdcd00">decltype</span>(A), <span style="color:#00cd00">int</span>, <span style="color:#cd00cd">1</span><span style="color:#39c">&gt;</span>,
</span>  <span style="color:#000080">// Whereas the &#39;f&#39;, however, naturally has the type (const) &#39;Foo&#39;.
</span><span style="color:#000080"></span>  C <span style="color:#39c">=</span> is_same_and_value_v<span style="color:#39c">&lt;</span><span style="color:#cdcd00">decltype</span>(f), <span style="color:#cdcd00">const</span> Foo, <span style="color:#cd00cd">5</span><span style="color:#39c">&gt;</span>,
};

<span style="color:#000080">// Outside of the definition, the type of each enumerator, however,
</span><span style="color:#000080">// is no longer that of the underlying type, but that of the enum.
</span><span style="display:block;width:100%;background-color:#191919"><span style="color:#000080"></span><span style="color:#cdcd00">static_assert</span>(std<span style="color:#39c">::</span>is_same_v<span style="color:#39c">&lt;</span><span style="color:#cdcd00">decltype</span>(Foo<span style="color:#39c">::</span>A), Foo<span style="color:#39c">&gt;</span>, <span style="color:#cd0000">&#34;&#34;</span>);
</span><span style="color:#cdcd00">static_assert</span>(<span style="color:#39c">!</span>std<span style="color:#39c">::</span>is_same_v<span style="color:#39c">&lt;</span><span style="color:#cdcd00">decltype</span>(Foo<span style="color:#39c">::</span>B), <span style="color:#00cd00">int</span><span style="color:#39c">&gt;</span>, <span style="color:#cd0000">&#34;&#34;</span>);

<span style="color:#00cd00">int</span> main() {}
</code></pre></div>
<p>It is this property of enumerators that allows initializing an enumerator
with a constant expression that makes use of the value of another enumerator
whose definition precedes it, without having to rely on implicit conversion
between the enume type and its underlying type (for which special rules applies, which we briefly visit below).</p>
<h4>Implicit and explicit conversions from enum types to their underlying types</h4>
<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf">N2347</a><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> (<em>Strongly Typed Enums (revision 3)</em>) introduced strongly typed enums, addressing the problems of weak typing, <em>implicit conversions</em> (that followed from the former), implementation-defined underlying types and weak scoping of the unscoped enums inherited from C.</p>
<p>In the context of this post, we may note that the value of an enumerator of or object of an <em>unscoped</em> enum type can be implicitly converted to an integer by integral conversion and integral promotion, as governed by <a href="https://timsong-cpp.github.io/cppwp/n4659/conv.integral#1">{conv.integral}/1</a> and <a href="https://timsong-cpp.github.io/cppwp/n4659/conv.prom#4">{conv.prom}/4</a> (<a href="https://timsong-cpp.github.io/cppwp/n4659/conv.prom#3">{conv.prom}/3</a> for unscoped enum types whose underlying type is not fixed), respectively [ <strong>emphasis</strong> mine]:</p>
<blockquote>
<p><strong>[conv.integral]/1</strong> A prvalue of an integer type can be converted to a prvalue of another integer type. A prvalue of an <strong>unscoped enumeration</strong> type can be converted to a prvalue of an integer type.</p>
<p><strong>[conv.prom]/4</strong> A prvalue of <strong>an unscoped enumeration type</strong> whose underlying type is fixed ([dcl.enum]) <strong>can be converted to a prvalue of its underlying type</strong>. Moreover, if integral promotion can be applied to its underlying type, a prvalue of an unscoped enumeration type whose underlying type is fixed can also be converted to a prvalue of the promoted underlying type.</p>
</blockquote>
<p>This means the following program, where <code>Foo</code> is an <em>unscoped</em> enum with <em>fixed underlying type</em>, is well-formed:</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000080">#include</span> <span style="color:#000080">&lt;iostream&gt;</span><span style="color:#000080">
</span><span style="color:#000080"></span>
<span style="color:#cdcd00">enum</span> <span style="color:#00cdcd">Foo</span><span style="color:#39c">:</span> <span style="color:#00cd00">int</span>;
<span style="color:#cdcd00">constexpr</span> Foo f <span style="color:#39c">=</span> <span style="color:#cdcd00">static_cast</span><span style="color:#39c">&lt;</span>Foo<span style="color:#39c">&gt;</span>(<span style="color:#cd00cd">0</span>);

<span style="color:#cdcd00">enum</span> <span style="color:#00cdcd">Foo</span><span style="color:#39c">:</span> <span style="color:#00cd00">int</span> {
<span style="display:block;width:100%;background-color:#191919">  A <span style="color:#39c">=</span> f,  <span style="color:#000080">// Implicit conversion from &#39;Foo&#39; to &#39;int&#39;.
</span></span><span style="color:#000080"></span>  B
};

<span style="color:#00cd00">int</span> main() {
    <span style="color:#cdcd00">switch</span>(f) {
        <span style="color:#cdcd00">case</span> Foo<span style="color:#39c">::</span>A: std<span style="color:#39c">::</span>cout <span style="color:#39c">&lt;&lt;</span> <span style="color:#cd0000">&#34;Foo::A</span><span style="color:#cd0000">\n</span><span style="color:#cd0000">&#34;</span>; <span style="color:#cdcd00">break</span>;
        <span style="color:#cdcd00">default</span><span style="color:#39c">:</span> std<span style="color:#39c">::</span>cout <span style="color:#39c">&lt;&lt;</span> <span style="color:#cd0000">&#34;Not Foo::A;&#34;</span>; <span style="color:#cdcd00">break</span>;
    }  <span style="color:#000080">// Foo::A
</span><span style="color:#000080"></span>}
</code></pre></div>
<p>Whereas the similar example where <code>Foo</code> has been changed into a <em>scoped</em> enum (still with a fixed underlying type) is ill-formed:</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#cdcd00">enum</span> <span style="color:#cdcd00">class</span> <span style="color:#00cdcd">Foo</span><span style="color:#39c">:</span> <span style="color:#00cd00">int</span>;
<span style="color:#cdcd00">constexpr</span> Foo f <span style="color:#39c">=</span> <span style="color:#cdcd00">static_cast</span><span style="color:#39c">&lt;</span>Foo<span style="color:#39c">&gt;</span>(<span style="color:#cd00cd">0</span>);

<span style="color:#cdcd00">enum</span> <span style="color:#cdcd00">class</span> <span style="color:#00cdcd">Foo</span><span style="color:#39c">:</span> <span style="color:#00cd00">int</span> {
<span style="display:block;width:100%;background-color:#191919">  A <span style="color:#39c">=</span> f,  <span style="color:#000080">// Error: could not convert &#39;f&#39; from &#39;const Foo&#39; to &#39;int&#39;.
</span></span><span style="color:#000080"></span>  B
};
</code></pre></div>
<p>This was part of the design intent of scoped enums from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf">N2347</a>, particularly addressing the problems stemming from allowing implicit conversion from an enumerator of or an object of an unscoped enum type to an integer. With scoped enums, we are now required to apply explicit type conversion when converting from scoped enums or enumerators of scoped enums to integers, e.g. particularly when converting to their underlying integer types.</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#cdcd00">enum</span> <span style="color:#cdcd00">class</span> <span style="color:#00cdcd">Foo</span><span style="color:#39c">:</span> <span style="color:#00cd00">int</span>;
<span style="color:#cdcd00">constexpr</span> Foo f <span style="color:#39c">=</span> <span style="color:#cdcd00">static_cast</span><span style="color:#39c">&lt;</span>Foo<span style="color:#39c">&gt;</span>(<span style="color:#cd00cd">0</span>);

<span style="color:#cdcd00">enum</span> <span style="color:#cdcd00">class</span> <span style="color:#00cdcd">Foo</span><span style="color:#39c">:</span> <span style="color:#00cd00">int</span> {
<span style="display:block;width:100%;background-color:#191919">  A <span style="color:#39c">=</span> <span style="color:#cdcd00">static_cast</span><span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span><span style="color:#39c">&gt;</span>(f), <span style="color:#000080">// OK.
</span></span><span style="color:#000080"></span>  B
};
</code></pre></div>
<h4>Upcoming enum improvements</h4>
<p>We will wrap up by mentioning the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1099r5.html">P1099R5</a> (<em>Using Enum</em>) proposal, which was accepted in time to make it into the C++20 standard, and which allows to associate enums with a <em>using directive</em> [extract]:</p>
<blockquote>
<p><strong>Abstract</strong> Class enums are restricted namespaces. Letâ€™s extend the using declaration to them.</p>
<p>[&hellip;] Consider an enum class:</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#cdcd00">enum</span> <span style="color:#cdcd00">class</span> <span style="color:#00cdcd">rgba_color_channel</span> { red, green, blue, alpha };
</code></pre></div><p>Currently, a switch using this enum looks as follows:</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">  <span style="color:#cdcd00">switch</span> (channel) {
    <span style="color:#cdcd00">case</span> rgba_color_channel<span style="color:#39c">::</span>red:   <span style="color:#cdcd00">return</span> <span style="color:#cd0000">&#34;red&#34;</span>;
    <span style="color:#cdcd00">case</span> rgba_color_channel<span style="color:#39c">::</span>green: <span style="color:#cdcd00">return</span> <span style="color:#cd0000">&#34;green&#34;</span>;
    <span style="color:#cdcd00">case</span> rgba_color_channel<span style="color:#39c">::</span>blue:  <span style="color:#cdcd00">return</span> <span style="color:#cd0000">&#34;blue&#34;</span>;
    <span style="color:#cdcd00">case</span> rgba_color_channel<span style="color:#39c">::</span>alpha: <span style="color:#cdcd00">return</span> <span style="color:#cd0000">&#34;alpha&#34;</span>;
  }
}
</code></pre></div><p>[&hellip;] The above example would then be rewritten as</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">std<span style="color:#39c">::</span>string_view to_string(rgba_color_channel channel) {
  <span style="color:#cdcd00">switch</span> (my_channel) {
    <span style="color:#cdcd00">using</span> <span style="color:#cdcd00">enum</span> <span style="color:#00cdcd">rgba_color_channel</span>;
    <span style="color:#cdcd00">case</span> red:   <span style="color:#cdcd00">return</span> <span style="color:#cd0000">&#34;red&#34;</span>;
    <span style="color:#cdcd00">case</span> green: <span style="color:#cdcd00">return</span> <span style="color:#cd0000">&#34;green&#34;</span>;
    <span style="color:#cdcd00">case</span> blue:  <span style="color:#cdcd00">return</span> <span style="color:#cd0000">&#34;blue&#34;</span>;
    <span style="color:#cdcd00">case</span> alpha: <span style="color:#cdcd00">return</span> <span style="color:#cd0000">&#34;alpha&#34;</span>;
  }
}
</code></pre></div><p>[&hellip;] This change is meant to allow the introduction of class members that are enumerators into non-class scope. [&hellip;]</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">S</span> {
    <span style="color:#cdcd00">enum</span> <span style="color:#00cdcd">E</span> { x };
    <span style="color:#cdcd00">enum</span> <span style="color:#cdcd00">class</span> <span style="color:#00cdcd">EC</span> { y };
    <span style="color:#cdcd00">using</span> EC<span style="color:#39c">::</span>y;
};

<span style="color:#00cd00">void</span> f() {
    <span style="color:#cdcd00">using</span> S<span style="color:#39c">::</span>x; <span style="color:#000080">// OK
</span><span style="color:#000080"></span>    x; <span style="color:#000080">// resolves to S::E::x;
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">using</span> S<span style="color:#39c">::</span>y; <span style="color:#000080">// OK
</span><span style="color:#000080"></span>    y; <span style="color:#000080">// resolves to S::EC::y;
</span><span style="color:#000080"></span>}
</code></pre></div><p>[&hellip;]</p>
<p>This paper has been approved by CWG in Cologne 2019 for C++20 after being approved by EWG in Kona 2019 (ship vehicle C++20).</p>
</blockquote>
</p>
</details>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>N2347 was integrated into the C++0X draft, which eventually became the C++11 standard. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

			

			
			
			
			
	        
	        
	        
	        
			
			    

                
				
				

			
				<div class="paging">
					<span class="paging-label">More Reading</span>

					

                    
					<div class="paging-newer">
						<span class="dark-red">Older</span><span class="decorative-marker">//</span>
						<a class="paging-link" href="https://dfrib.github.io/the-fickle-aggregate/">The fickle aggregate</a>
		            </div>
		            
	            </div>
                    

                    
                    
          </section>
          
          	<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "dfrib" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          
        
      <div class="footer">
	<hr class="thin" />
	<div class="pure-menu pure-menu-horizontal pure-menu-open">
		<ul class="footer-menu">
		
		</ul>
	</div>

	<p>&copy; 2019-2020 David Friberg</p>
</div>
    </div>
  </div>
	

	

  
</body>
</html>
