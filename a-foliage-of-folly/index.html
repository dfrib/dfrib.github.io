<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <title>
    A foliage of folly // [unfold] Bits of awareness
  </title>

  <link href="https://gmpg.org/xfn/11" rel="profile">
<meta http-equiv="content-type" content="text/html; charset=utf-8">


<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

<meta name="description" content="">
<meta name="keywords" content="">
<meta name="author" content="[David Friberg]">
<meta name="generator" content="Hugo 0.75.1" />


  <meta property="og:title" content="A foliage of folly" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:locale" content="en_US" />
<meta property="og:url" content="https://dfrib.github.io/a-foliage-of-folly/" />


  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/base-min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/pure-min.css">
  
  
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.5.0/grids-responsive-min.css">
  
  

   
   <link rel="stylesheet" href="https://dfrib.github.io/css/redlounge.css">
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
  <link href='//fonts.googleapis.com/css?family=Raleway:400,200,100,700,300,500,600,800' rel='stylesheet' type='text/css'>
  <link href='//fonts.googleapis.com/css?family=Libre+Baskerville:400,700,400italic' rel='stylesheet' type='text/css'>

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://dfrib.github.io/touch-icon-144-precomposed.png">
  <link rel="shortcut icon" type="image/x-icon" href="https://dfrib.github.io/img/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="[unfold] Bits of awareness" />

  


  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/atom-one-dark.min.css">
  <link rel="stylesheet" href="https://dfrib.github.io/css/override.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js"></script>
  <script
    charset="UTF-8"
    src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/lisp.min.js"></script>
  <script
    charset="UTF-8"
    src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/swift.min.js"></script>
  <script
    charset="UTF-8"
    src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/cmake.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>


  

  

  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-179323449-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


  
</head>

<body>
	

	<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
  <div class="header">
    

	

    <h1 class="brand-title">[unfold]</h1>
    <h2 class="brand-tagline">Bits of awareness</h2>

    <nav class="nav">
      <ul class="nav-list">
        
        
          <li class="nav-item"><span class="nav-item-separator">//</span><a href="https://dfrib.github.io/">Home</a></li>
        
          <li class="nav-item"><span class="nav-item-separator">//</span><a href="https://dfrib.github.io/categories/cplusplus">C&#43;&#43;</a></li>
        
          <li class="nav-item"><span class="nav-item-separator">//</span><a href="https://dfrib.github.io/categories/emacs">Emacs</a></li>
        
      </ul>
    </nav>

    
    <div class="social-buttons">
      
        
        <a href="https://github.com/dfrib" target="_blank"><i class ='fa fa-github'></i></a>
        
      
        
        <a href="https://www.linkedin.com/in/david-friberg-7642863a" target="_blank"><i class ='fa fa-linkedin'></i></a>
        
      
        
        <a href="https://stackoverflow.com/users/4573247/dfri?tab=profile" target="_blank"><i class ='fa fa-stack-overflow'></i></a>
        
      
      
    </div>
    

  </div>
</div>

	
	

    <div class="content pure-u-1 pure-u-md-3-4">
		<a name="top"></a>
		

		
			
		    
			
		    
		    
		    
	    
  		<section class="post">
            <h1 class="post-title">
              <a href="https://dfrib.github.io/a-foliage-of-folly/">A foliage of folly</a>
            </h1>
            <h3 class="post-subtitle">
            	
            </h3>
            
            	
                
            	
            	
            
            	
            		
            		
            	
            

			
			
				<div class="post-categories">
				
					<a class="post-category post-category-cplusplus" href="https://dfrib.github.io/categories/cplusplus">cplusplus</a>
				
				</div>
			
            
				<div class="tags-list">
					<span class="dark-red">Tags</span><span class="decorative-marker">//</span>
					
	                <a class="post-tag post-tag-cpp" href="https://dfrib.github.io/tags/cpp">cpp</a>,
	                
	                <a class="post-tag post-tag-templates" href="https://dfrib.github.io/tags/templates">templates</a>,
	                
	                <a class="post-tag post-tag-accessprivate" href="https://dfrib.github.io/tags/accessprivate">accessprivate</a>,
	                
				</div>
			

			

			

            <blockquote>
<p>Can we circumvent the private access rules without relying on techniques that are considered &ldquo;arcane&rdquo; and likely to be made illegal (at some point)?</p>
</blockquote>
<p>I recently read the article <a href="https://accu.org/journals/overload/28/156/harrison%5F2776/">Profiting from the Folly of Others</a> by Alastair Harrison, which walks through a technique to circumvent private access rules, particularly by means of (ab)using the template instantiation mechanism together with injections of inline friend definitions. I first saw this technique used in Filip Roséen&rsquo;s blog article series on stateful metaprogramming back in 2015, which made use of it to implement a constexpr-counter that were, if not fully, at the very least nearly<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> standard compliant. A. Harrison&rsquo;s article mentions that the origin of the technique is likely two blog articles by Johannes Schaub published in 2010-2011<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>.</p>
<details>
<summary>
Spoiler / TL;DR
</summary>
<p class="details">
<p>Yes: see <a href="https://github.com/dfrib/accessprivate">dfrib / accessprivate</a> at GitHub.</p>
</p>
</details>
<p>The publication of Roséen&rsquo;s blog series swiftly lead to <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg%5Factive.html#2118">CWG issue 2118</a>, describing the technique to be <em>&quot;[&hellip;] arcane and should be made ill-formed&quot;</em>, but the issue is, still, yet<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup> to be addressed.</p>
<blockquote>
<p><strong>2118. Stateful metaprogramming via friend injection</strong></p>
<p><strong>Section:</strong> 17.7.5 [temp.inject]<br>
<strong>Status:</strong> open<br>
<strong>Submitter:</strong> Richard Smith<br>
<strong>Date:</strong> 2015-04-27</p>
<p>Defining a friend function in a template, then referencing that function later provides a means of capturing and retrieving metaprogramming state. This technique is arcane and should be made ill-formed.</p>
<p><strong>Notes from the May, 2015 meeting:</strong> <br>
CWG agreed that such techniques should be ill-formed, although the mechanism for prohibiting them is as yet undetermined.</p>
</blockquote>
<p>The core working group&rsquo;s main concern, afaict, is that the <em>definition</em> of the injected friend depends on <em>which specialization</em> of the template entity that is <em>first instantiated</em>, thus allowing one to capture a metaprogramming state<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>. For the purpose of circumventing private access rules, however, we have no actual need of capturing a metaprogramming state in this kind of sense, it just so happens that the most viable mechanism (thus far; prior to C++20) by which we may <em>legally</em> refer to a private entity beyond its intended access rules is by means of explicit instantiation definitions, which in turn lead us onto the path of <em>&ldquo;arcane&rdquo;</em> stateful metaprogramming.</p>
<p>In this blog post we&rsquo;ll walk through the established approach (applied to C++17), whereafter we will proceed to look into a new minor C++20 feature to see if we can create a novel approach to circumvention of access rules, one which does not rely on mechanisms that CWG issue 2118 intends to deprecate and make ill-formed.</p>
<h3 id="a-disclaimer-before-we-begin">A disclaimer before we begin</h3>
<p>This post is, like some others on my blog, driven from a curiousity (and sometimes also language-lawyer) perspective. However, as the end result in this post <a href="https://i.kym-cdn.com/photos/images/original/000/877/596/f66.jpg">can be particularly abused</a>, I want to highlight that <strong>thou shalt not use the techniques herein in production code</strong>. Or, by the words of Herb from <a href="http://www.gotw.ca/gotw/076.htm">GotW #76: Uses and Abuses of Access Rights</a>:</p>
<blockquote>
<h4>Is this a hole in C++'s access control mechanism, and therefore a hole in C++'s encapsulation? Discuss.</h4>
<p>[&hellip;]</p>
<p>The real answer to the issue is: Don&rsquo;t do that! Admittedly, even Scott Meyers has said publicly that there are times when it&rsquo;s tempting to have a quick way to bypass the access control mechanism temporarily, such as to produce better diagnostic output during debugging&hellip; but it&rsquo;s just not a habit you want to get into for production code, and it should appear on the list of &ldquo;one-warning offences&rdquo; in your development shop.</p>
</blockquote>
<p>The only actual use case (beyond extreme-case optimizations as used e.g. in <a href="https://github.com/facebook/folly/blob/f63a5c31680aaabcc0f9c86709fd4a813db292ce/folly/memory/UninitializedMemoryHacks.h"><code>UninitializedMemoryHacks.h</code></a> in Facebook&rsquo;s <a href="https://github.com/facebook/folly">Folly library</a>) I can come up with for this kind of technique, on the top of my head, is for some corner case testing scenarios, e.g. fault injection testing.</p>
<h2 id="the-problem-we-want-to-solve">The problem we want to solve</h2>
<p>Consider the following class</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000080">// foo.h
</span><span style="color:#000080"></span><span style="color:#000080">#pragma once
</span><span style="color:#000080">#include</span> <span style="color:#000080">&lt;iostream&gt;</span><span style="color:#000080">
</span><span style="color:#000080"></span>
<span style="color:#cdcd00">class</span> <span style="color:#00cdcd">Foo</span> {
    <span style="color:#00cd00">int</span> bar() <span style="color:#cdcd00">const</span> {
        std<span style="color:#39c">::</span>cout <span style="color:#39c">&lt;&lt;</span> __PRETTY_FUNCTION__;
        <span style="color:#cdcd00">return</span> x;
    }

    <span style="color:#00cd00">int</span> x{<span style="color:#cd00cd">42</span>};
};
</code></pre></div><p>which contains a private member function <code>bar</code> and a private data member <code>x</code>. The problem we&rsquo;re trying to solve is:</p>
<blockquote>
<p>Given an object of type <code>Foo</code>, can we somehow, without changes to <code>Foo</code> itself, access the private data member <code>x</code> and/or invoke the (non-overloaded) private member function <code>bar</code> whilst still using only standard conforming C++ code?</p>
</blockquote>
<p>or, in more general words, <em>can we circumvent the private access rules of C++ without relying on non-conforming code or implementation-defined mechanisms</em>?</p>
<h2 id="recalling-the-pre-c-plus-plus-20-approach--schaub-folly-library-et-al">Recalling the pre-C++20 approach (Schaub, Folly library et al)</h2>
<p><em>(We will be performing this pre-C++20 journey using C++17, and thus all standard references below refer to N4659<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>)</em></p>
<p>Before we move on to investigate whether a new minor feature of C++20 can help us circumvent access rules without inciting the anger of CWG issue 2118 or not, we&rsquo;ll walk through and make sure we understand the mechanisms as well as the pitfalls of the existing approach used e.g. in <a href="https://github.com/facebook/folly">the Fickle library</a>, and whose mechanisms are covered in detail also in <a href="https://accu.org/journals/overload/28/156/harrison%5F2776/">Profiting from the Folly of Others</a>.</p>
<p>The key feature of this approach is governed by <a href="https://timsong-cpp.github.io/cppwp/n4659/temp.explicit#12">[temp.explicit]/12</a>:</p>
<blockquote>
<p>The usual access checking rules do not apply to names used to specify explicit instantiations. [&hellip;]</p>
</blockquote>
<p>which allows the following snippet of code to be well-formed:</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#cdcd00">class</span> <span style="color:#00cdcd">A</span> { <span style="color:#00cd00">int</span> x; };

<span style="color:#cdcd00">template</span><span style="color:#39c">&lt;</span><span style="color:#cdcd00">auto</span><span style="color:#39c">&gt;</span>
<span style="color:#cdcd00">class</span> <span style="color:#00cdcd">B</span> {};

<span style="color:#000080">// Explicit instantiation definition.
</span><span style="display:block;width:100%;background-color:#191919"><span style="color:#000080"></span><span style="color:#cdcd00">template</span> <span style="color:#cdcd00">class</span> <span style="color:#00cdcd">B</span><span style="color:#39c">&lt;&amp;</span>A<span style="color:#39c">::</span>x<span style="color:#39c">&gt;</span>;
</span><span style="color:#000080">//               ^^^^^ access rules for private data
</span><span style="color:#000080">//                     member &#39;x&#39; is waived in an
</span><span style="color:#000080">//                     explicit instantiation definition.
</span></code></pre></div>
<p>This mechanism in itself is neither unusual nor a direct tool for language abuse, however for the purpose of circumventing private access rules it needs to be combined with a mechanism that is; namely defining, in a class template, a friend function whose definition relies on one or more template parameters, meaning the definition depends on which specialization of the class template is first instantiated.</p>
<h3 id="defining-a-friend-within-a-class-template">Defining a friend within a class template</h3>
<p>As governed by <a href="https://timsong-cpp.github.io/cppwp/n4659/class.friend#6">[class.friend]/6</a>, a function that is also a friend may be <em>defined</em> at its friend declaration within a class [ <strong>emphasis</strong> mine]:</p>
<blockquote>
<p>A function can be defined in a friend declaration of a class if and only if the class is a non-local class ([class.local]), the function name is unqualified, and <strong>the function has namespace scope</strong>. [ Example:</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#cdcd00">class</span> <span style="color:#00cdcd">M</span> {
  <span style="color:#cdcd00">friend</span> <span style="color:#00cd00">void</span> f() { }  <span style="color:#000080">// definition of global f, a friend of M,
</span><span style="color:#000080"></span>                       <span style="color:#000080">// not the definition of a member function
</span><span style="color:#000080"></span>};
</code></pre></div><p>— end example ]</p>
</blockquote>
<p>Such a friend function is implicitly inline, as per <a href="https://timsong-cpp.github.io/cppwp/n4659/class.friend#7">[class.friend]/7</a> [ <strong>emphasis</strong> mine]:</p>
<blockquote>
<p>Such a function <strong>is implicitly an inline function</strong>. A <code>friend</code> function defined in a class is in the (lexical) scope of the class in which it is defined. A friend function defined outside the class is not ([basic.lookup.unqual]).</p>
</blockquote>
<p>which is important as it allows the definition to be present in multiple translation units (TU) without ODR-violations, given that it is the same definition. Specifically, if the definition of say the class <code>M</code> above were to be located in a header file that was included by several source files, then the corresponding TU:s would all include their own definition of the global (inline) function <code>f</code>, which would be fine, as per <a href="https://timsong-cpp.github.io/cppwp/n4659/basic.def.odr#6">[basic.def.odr]/6</a>, as the definition in each TU would be the same.</p>
<p>Now, although a function defined at its friend declaration has namespace scope, a friend declaration does not introduce the declared name into the enclosing namespace, as per <a href="https://timsong-cpp.github.io/cppwp/n4659/namespace.memdef#3">[namespace.memdef]/3</a> [ <strong>emphasis</strong> mine]:</p>
<blockquote>
<p>If a friend declaration in a non-local class <strong>first declares</strong> class, function, class template or function template <strong>the friend is a member of the innermost enclosing namespace</strong>. The friend declaration <strong>does not by itself make the name visible to unqualified lookup</strong> ([basic.lookup.unqual]) or qualified lookup ([basic.lookup.qual]). [ Note: The name of the friend <strong>will be visible in its namespace if a matching declaration is provided at namespace scope</strong> (either before or after the class definition granting friendship).  — end note ] [&hellip;]</p>
</blockquote>
<p>meaning a matching declaration needs to be provided at namespace scope to allow the friend function to be found via non-ADL lookup<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup>:</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">C</span> {
<span style="display:block;width:100%;background-color:#191919">    <span style="color:#cdcd00">friend</span> <span style="color:#00cd00">void</span> f() { }
</span>    <span style="color:#cdcd00">friend</span> <span style="color:#00cd00">void</span> g() { }
};
<span style="display:block;width:100%;background-color:#191919"><span style="color:#00cd00">void</span> f();
</span>
<span style="color:#00cd00">int</span> main() {
<span style="display:block;width:100%;background-color:#191919">    f(); <span style="color:#000080">// OK.
</span></span><span style="color:#000080"></span>    g(); <span style="color:#000080">// Error: &#39;g&#39; was not declared in this scope.
</span><span style="color:#000080"></span>}
</code></pre></div>
<p>Now, nothing prohibits us from supplying friend declarations in class templates, and we can likewise, as for the non-template class, <em>define</em> the friends at their friend declarations:</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#cdcd00">template</span><span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span> N<span style="color:#39c">&gt;</span>
<span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">D</span> {
    <span style="color:#cdcd00">friend</span> <span style="color:#00cd00">void</span> f() { }
};
<span style="color:#00cd00">void</span> f();
</code></pre></div><p>As per the instantiation rules of template entites, the definition of the friend will not be instantiated until at least one explicit or implicit instantiation of the class template <code>D</code> takes place, even though <code>f</code> itself is not a template function nor a member of a class template; it is free namespace scope function.</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#cdcd00">template</span><span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span> N<span style="color:#39c">&gt;</span>
<span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">D</span> {
    <span style="color:#cdcd00">friend</span> <span style="color:#00cd00">void</span> f() { }
};
<span style="color:#00cd00">void</span> f();

<span style="color:#cdcd00">template</span><span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span> N<span style="color:#39c">&gt;</span>
<span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">E</span> {
    <span style="color:#cdcd00">friend</span> <span style="color:#00cd00">void</span> g() { }
};
<span style="color:#00cd00">void</span> g();

<span style="color:#00cd00">int</span> main() {
    D<span style="color:#39c">&lt;</span><span style="color:#cd00cd">1</span><span style="color:#39c">&gt;</span> a;  <span style="color:#000080">// Instantiaces _a_ specialization of &#39;D&#39;
</span><span style="color:#000080"></span>    f(); <span style="color:#000080">// OK (definition &#34;instantiated&#34; along D&lt;1&gt;)
</span><span style="display:block;width:100%;background-color:#191919"><span style="color:#000080"></span>    g(); <span style="color:#000080">// Error: undefined reference to &#39;g()&#39;.
</span></span><span style="color:#000080"></span>}
</code></pre></div>
<h3 id="danger-will-robinson">Danger, Will Robinson!</h3>
<p>However, we&rsquo;ve now entered a territory that comes with a number of dangers; some diagnosable and arguably at worst confusing for the developer debugging the associated compiler errors, but some that are worse than that.</p>
<ol>
<li>
<p><em>(Diagnosable)</em> As per above, the definition of <code>f</code> will only be present if the class template <code>D</code> is instantiated (for <em>any specialization</em>); prior to the first instantiation of <code>D</code>, <code>f</code> remains undefined. On the othe hand, if <em>more than one</em> specialization is instantiated in the same translation unit, <code>f</code> will be re-defined (albeit with the same definition) and the program is ill-formed by violation of <a href="https://timsong-cpp.github.io/cppwp/n4659/basic.def.odr#1">[basic.def.odr]/1</a></p>
<blockquote>
<p>No translation unit shall contain more than one definition of any variable, function, class type, enumeration type, or template.</p>
</blockquote>
</li>
<li>
<p><em>(Diagnosable)</em> Every translation unit in which <code>f</code> is odr-used needs to define <code>f</code>, as per <a href="https://timsong-cpp.github.io/cppwp/n4659/basic.def.odr#4">[basic.def.odr]/4</a></p>
<blockquote>
<p>[&hellip;] An inline function or variable shall be defined in every translation unit in which it is odr-used outside of a discarded statement.</p>
</blockquote>
<p>meaning that if the class template <code>D</code> above were to be declared in a header, say <code>d.h</code>, then every TU that that included <code>d.h</code> and odr-used <code>f</code> would <em>need to instantiate</em> the class template <code>D</code>, implicitly or explicitly, <em>exactly for one specialization</em>.</p>
</li>
<li>
<p><em>(Non-diagnosable; undefined behaviour)</em> If the definition of <code>f</code> depends on any of the template parameters of the class template in which it has been defined, e.g.</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">   <span style="color:#000080">// d.h
</span><span style="color:#000080"></span>   <span style="color:#000080">#pragma once
</span><span style="color:#000080"></span>   <span style="color:#cdcd00">template</span><span style="color:#39c">&lt;</span><span style="color:#00cd00">int</span> N, <span style="color:#00cd00">bool</span> B, <span style="color:#cdcd00">typename</span> T<span style="color:#39c">&gt;</span>
   <span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">D</span> {
       <span style="color:#cdcd00">friend</span> <span style="color:#00cd00">void</span> f() { <span style="color:#00cd00">int</span> x{N}; (<span style="color:#00cd00">void</span>)x; }
       <span style="color:#000080">// ...
</span><span style="color:#000080"></span>   };
   <span style="color:#00cd00">void</span> f();
</code></pre></div><p>then every TU which includes <code>d.h</code> and instantiates the class template <code>D</code>, implicitly or explicitly, must as per above (1) instantiate it no more than for <em>one specialization</em> (diagnosable), but moreover that specialization needs to be one that has <em>exactly the same template argument</em> for each template parameter that is used within the definition of <code>f</code>, as the definition of <code>f</code> needs to be the same over all TU:s, as per <a href="https://timsong-cpp.github.io/cppwp/n4659/basic.def.odr#6">[basic.def.odr]/6</a>. In the example above, the latter would mean that the single instantiation of <code>D</code> in each TU would need to use exactly the same value for the non-type template parameter <code>N</code>.</p>
</li>
<li>
<p><em>(Ill-formed NDR)</em> If we leverage explicit instantiation definitions, we may not explicitly instantiate the same specialization twice over different translation units, as per <a href="https://timsong-cpp.github.io/cppwp/n4659/temp.spec#5">[temp.spec]/5</a> [ <strong>emphasis</strong> mine]:</p>
<blockquote>
<p>For a given template and a given set of template-arguments,<br>
— (5.1) an explicit instantiation definition <strong>shall appear at most once in a program</strong>,<br>
— [&hellip;]<br>
An implementation is not required to diagnose a violation of this rule.</p>
</blockquote>
<p>meaning that two explicit instantiation definitions of <code>D</code> above, in different TU:s, must instantiate <em>different</em> specializations but, as per (3), specializations that both use the <em>same</em> value as template argument for the template parameter <code>N</code>.</p>
</li>
</ol>
<p>Now, this is arguably quite a mess, and any sane advice would be to stop now and never enter this minefield of ODR-violations, UB and ill-formed NDR. However, for the purpose of circumventing private access rules prior to C++20, it is precisely down this path that we need to walk.</p>
<h3 id="circumvention-of-private-access-rules-by-injection-of-pointers-to-private-members-into-friends">Circumvention of private access rules by injection of pointers to private members into friends</h3>
<p>To finally construct the circumvention mechanism in C++17, we leverage <a href="https://timsong-cpp.github.io/cppwp/n4659/temp.explicit#12">[temp.explicit]/12</a> to supply a pointer to a private data member or pointer to a private member function as a non-template parameter as part of the explicit instantiation definition of a class template which contains a friend declaration that captures and &ldquo;access-rule-erases&rdquo;, if you will, the supplied pointer to member into its definition. A first attempt, focusing on invoking the private member function <code>bar</code> of <code>Foo</code> may look like follows:</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000080">// access_private_of_foo.h
</span><span style="color:#000080"></span><span style="color:#000080">#pragma once
</span><span style="color:#000080">#include</span> <span style="color:#000080">&#34;foo.h&#34;</span><span style="color:#000080">
</span><span style="color:#000080"></span>
<span style="color:#cdcd00">template</span> <span style="color:#39c">&lt;</span><span style="color:#cdcd00">auto</span> mem_fn_ptr<span style="color:#39c">&gt;</span>
<span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">InvokePrivateFooBar</span> {
    <span style="color:#000080">// (Injected) friend definition.
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">friend</span> <span style="color:#00cd00">int</span> private_Foo_bar(Foo <span style="color:#cdcd00">const</span><span style="color:#39c">&amp;</span> foo) {
        <span style="color:#cdcd00">return</span> (foo.<span style="color:#39c">*</span>mem_fn_ptr)();
    }
};
<span style="color:#000080">// Friend (re-)declaration.
</span><span style="color:#000080"></span><span style="color:#00cd00">int</span> private_Foo_bar(Foo <span style="color:#cdcd00">const</span><span style="color:#39c">&amp;</span> foo);

<span style="color:#000080">// Explicit instantiation definition immediately after
</span><span style="color:#000080">// class template definition, to ensure this instantiation
</span><span style="color:#000080">// is the first of the class template.
</span><span style="color:#000080"></span><span style="color:#cdcd00">template</span> <span style="color:#cdcd00">class</span> <span style="color:#00cdcd">InvokePrivateFooBar</span><span style="color:#39c">&lt;&amp;</span>Foo<span style="color:#39c">::</span>bar<span style="color:#39c">&gt;</span>;
</code></pre></div><p>which is well-formed by itself, but which may stumble over both of the serious (non-diagnosable) dangers of (3) and (4) above. By our careful understanding of (3) and (4), however, they can be mitigated.</p>
<p>We <em>could</em> implement the entirety of the private access circumvention mechanism within an unnamed namespace within single TU, which would remove the cross-TU dangers of (3) and (4), but such an approach would limit re-use, and may arguably make its way into someone&rsquo;s header files sooner or later anyway.</p>
<p>A more common approach is to introduce an additional type template parameter to the class template (<code>InvokePrivateFooBar</code> here), and use a TU unique tag type as template argument for that template parameter in the single explicit instantiation definition. Leveraging the fact that unnamed namespaces are unique and have internal linkage, we may wrap a type definition within an unnamed namespace <em>in a header file</em>, with the result that the type will be guaranteed to be a different type in each TU that includes the header file. This would also alleviate the dangers of 3 and 4, as the single explicit instantiation definition, following immediately after the class template in the header, would use the same template arguments for all template parameters who are used (/injected into) the body of the friend, but would use the dummy TU tag type to differentiate the explicit instantiation definition between different TU:s. Any attempt by a user to instantiate another specialization than the from-header provided one would violate [basic.def.odr]/1 (2 above), which is diagnosable, so at least the compiler could help us out if we enter the territory of danger 2 above (and the same holds for 1).</p>
<p>With this in mind, our second attempt looks as follows, where we&rsquo;ve expanded the circumvention API with a structure for accessing also the private data member <code>x</code> of <code>Foo</code>.</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000080">// access_private_of_foo.h
</span><span style="color:#000080"></span><span style="color:#000080">#pragma once
</span><span style="color:#000080">#include</span> <span style="color:#000080">&#34;foo.h&#34;</span><span style="color:#000080">
</span><span style="color:#000080"></span>
<span style="color:#000080">// Unique namespace in each TU.
</span><span style="color:#000080"></span><span style="color:#cdcd00">namespace</span> {
<span style="color:#000080">// Unique type in each TU (internal linkage).
</span><span style="color:#000080"></span><span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">TranslationUnitTag</span> {};
}  <span style="color:#000080">// namespace
</span><span style="color:#000080"></span>
<span style="color:#000080">// &#39;Foo::bar()&#39; invoker.
</span><span style="color:#000080"></span><span style="color:#cdcd00">template</span> <span style="color:#39c">&lt;</span><span style="color:#cdcd00">typename</span> UniqueTag,
          <span style="color:#cdcd00">auto</span> mem_fn_ptr<span style="color:#39c">&gt;</span>
<span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">InvokePrivateFooBar</span> {
    <span style="color:#000080">// (Injected) friend definition.
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">friend</span> <span style="color:#00cd00">int</span> invoke_private_Foo_bar(Foo <span style="color:#cdcd00">const</span><span style="color:#39c">&amp;</span> foo) {
        <span style="color:#cdcd00">return</span> (foo.<span style="color:#39c">*</span>mem_fn_ptr)();
    }
};
<span style="color:#000080">// Friend (re-)declaration.
</span><span style="color:#000080"></span><span style="color:#00cd00">int</span> invoke_private_Foo_bar(Foo <span style="color:#cdcd00">const</span><span style="color:#39c">&amp;</span> foo);

<span style="color:#000080">// Single explicit instantiation definition.
</span><span style="color:#000080"></span><span style="color:#cdcd00">template</span> <span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">InvokePrivateFooBar</span><span style="color:#39c">&lt;</span>TranslationUnitTag, <span style="color:#39c">&amp;</span>Foo<span style="color:#39c">::</span>bar<span style="color:#39c">&gt;</span>;

<span style="color:#000080">// &#39;Foo::x&#39; accessor.
</span><span style="color:#000080"></span><span style="color:#cdcd00">template</span> <span style="color:#39c">&lt;</span><span style="color:#cdcd00">typename</span> UniqueTag,
          <span style="color:#cdcd00">auto</span> mem_ptr<span style="color:#39c">&gt;</span>
<span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">AccessPrivateMemFooX</span> {
    <span style="color:#000080">// (Injected) friend definition.
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">friend</span> <span style="color:#00cd00">int</span><span style="color:#39c">&amp;</span> access_private_Foo_x(Foo<span style="color:#39c">&amp;</span> foo) {
        <span style="color:#cdcd00">return</span> foo.<span style="color:#39c">*</span>mem_ptr;
    }
};
<span style="color:#000080">// Friend (re-)declaration.
</span><span style="color:#000080"></span><span style="color:#00cd00">int</span><span style="color:#39c">&amp;</span> access_private_Foo_x(Foo<span style="color:#39c">&amp;</span> foo);

<span style="color:#000080">// Single explicit instantiation definition.
</span><span style="color:#000080"></span><span style="color:#cdcd00">template</span> <span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">AccessPrivateMemFooX</span><span style="color:#39c">&lt;</span>TranslationUnitTag, <span style="color:#39c">&amp;</span>Foo<span style="color:#39c">::</span>x<span style="color:#39c">&gt;</span>;
</code></pre></div><p>which we may use in a particular source file as follows:</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000080">// demo.cpp
</span><span style="color:#000080"></span><span style="color:#000080">#include</span> <span style="color:#000080">&lt;iostream&gt;</span><span style="color:#000080">
</span><span style="color:#000080">#include</span> <span style="color:#000080">&#34;access_private_of_foo.h&#34;</span><span style="color:#000080">
</span><span style="color:#000080">#include</span> <span style="color:#000080">&#34;foo.h&#34;</span><span style="color:#000080">
</span><span style="color:#000080"></span>
<span style="color:#00cd00">void</span> demo() {
    Foo f{};

    <span style="color:#00cd00">int</span> hidden <span style="color:#39c">=</span> invoke_private_Foo_bar(f);  <span style="color:#000080">// int Foo::bar() const
</span><span style="color:#000080"></span>    std<span style="color:#39c">::</span>cout <span style="color:#39c">&lt;&lt;</span> hidden <span style="color:#39c">&lt;&lt;</span> <span style="color:#cd0000">&#34;</span><span style="color:#cd0000">\n</span><span style="color:#cd0000">&#34;</span>;  <span style="color:#000080">// 42
</span><span style="color:#000080"></span>
    access_private_Foo_x(f) <span style="color:#39c">=</span> <span style="color:#cd00cd">13</span>;
    hidden <span style="color:#39c">=</span> invoke_private_Foo_bar(f);  <span style="color:#000080">// int Foo::bar() const
</span><span style="color:#000080"></span>    std<span style="color:#39c">::</span>cout <span style="color:#39c">&lt;&lt;</span> hidden <span style="color:#39c">&lt;&lt;</span> <span style="color:#cd0000">&#34;</span><span style="color:#cd0000">\n</span><span style="color:#cd0000">&#34;</span>;  <span style="color:#000080">// 13
</span><span style="color:#000080"></span>}
</code></pre></div><p>and we have thus reached the goal of circumvention of private access rules using a C++17 approach; particularly here applied to the <code>Foo</code> class, invoking the private member function <code>bar</code> as well as writing to the private data member <code>x</code>.</p>
<p><a href="https://wandbox.org/permlink/ttKuVlrsMe2AycJo">Demo</a>.</p>
<p>We move on to look into finding an alternative approach, by making use of a new minor feature of C++20.</p>
<h2 id="c-plus-plus-20-and-waiving-of-access-checking-on-specializations">C++20 &amp; waiving of access checking on specializations</h2>
<p><em>(As we are now moving to C++20, all standard references from hereon refers to N4861<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup>)</em></p>
<p>C++20 implemented <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0692r1.html">P0692R1</a> (<em>Access Checking on Specializations</em>), summarized in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2131r0.html">P2131R0</a> (<em>Changes between C++17 and C++20 DIS</em>) as</p>
<blockquote>
<p>This change fixes a long-standing, somewhat obscure situation, where it was not possible to declare a template specialization for a template argument that is a private (or protected) member type. For example, given <code>class Foo { class Bar {}; };</code>, the access <code>Foo::Bar</code> is now allowed in <code>template&lt;class&gt; struct X; template&lt;&gt; struct X&lt;Foo::Bar&gt;;</code>.</p>
</blockquote>
<p>particularly adding <a href="https://timsong-cpp.github.io/cppwp/n4861/temp.spec#6">[temp.spec]/6</a> to the C++20 standard:</p>
<blockquote>
<p><strong>The usual access checking rules do not apply to names in a declaration of an</strong> explicit instantiation or <strong>explicit specialization</strong>, with the exception of names appearing in a function body, default argument, base-clause, member-specification, enumerator-list, or static data member or variable template initializer. [ Note: <strong>In particular, the template arguments</strong> and names used in the function declarator (including parameter types, return types and exception specifications) <strong>may be private types or objects that would normally not be accessible.</strong> — end note ]</p>
</blockquote>
<p>This opens up a new approach for circumvention of private access rules, one which does not fall under CWG issue 2118, and moreover offers more freedom and fewer gotchas than that of the explicit instantiation hack.</p>
<h3 id="common-top-level-private-accessor-class">Common top-level private accessor class</h3>
<p>Specializations can allow us to use a single top-level utility class template for circumvention of private access rules of <em>any</em> class, as compared to the C++17 approach above where a new class (template) needs to be defined for each unique member of a unique type that we want to access.</p>
<p>With the specialization approach we still leverage the in-class friend definition trick, but leaves such friend declarations to appear only in explicit specializations of a member class to the top-level utility class. Specifically, we let the latter be a class template with a single non-type template parameter—semantically intended to take arguments that are pointers to private members—which is used to initialize a single static data member, and <em>declare</em> a member class in the class template that is intended to be <em>defined only in explicit specializations</em>:</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000080">// accessprivate.h
</span><span style="color:#000080"></span><span style="color:#000080">#pragma once
</span><span style="color:#000080"></span><span style="color:#cdcd00">template</span> <span style="color:#39c">&lt;</span><span style="color:#cdcd00">auto</span> mem_ptr<span style="color:#39c">&gt;</span>
<span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">AccessPrivate</span>
{
    <span style="color:#000080">// kMemPtr is intended to be either a pointer to a private
</span><span style="color:#000080"></span>    <span style="color:#000080">// member function or pointer to a private data member.
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">static</span> <span style="color:#cdcd00">constexpr</span> <span style="color:#cdcd00">auto</span> kMemPtr <span style="color:#39c">=</span> mem_ptr;
    <span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">Delegate</span>;  <span style="color:#000080">// Define only in explicit specializations.
</span><span style="color:#000080"></span>};
</code></pre></div><p>Each explicit specialization of the templated class <code>AccessPrivate::Delegate</code> (a member class of class template is likewise a templated class) can declare a unique friend function which is defined at its friend declaration, and whose definition makes use of the particular instantantiation of the access-erased <code>kMemPtr</code> for that very specialization:</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000080">// access_private_of_foo_cpp20.h
</span><span style="color:#000080"></span><span style="color:#000080">#pragma once
</span><span style="color:#000080">#include</span> <span style="color:#000080">&#34;accessprivate.h&#34;</span><span style="color:#000080">
</span><span style="color:#000080">#include</span> <span style="color:#000080">&#34;foo.h&#34;</span><span style="color:#000080">
</span><span style="color:#000080"></span>
<span style="color:#000080">// Specialize the nested Delegate class for each private
</span><span style="color:#000080">// member function or data member of Foo that we&#39;d like to access.
</span><span style="color:#000080"></span>
<span style="color:#cdcd00">template</span> <span style="color:#39c">&lt;&gt;</span>
<span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">AccessPrivate</span><span style="color:#39c">&lt;&amp;</span>Foo<span style="color:#39c">::</span>bar<span style="color:#39c">&gt;::</span>Delegate {
    <span style="color:#000080">// (Injected) friend definition.
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">friend</span> <span style="color:#00cd00">int</span> invoke_private_Foo_bar(Foo <span style="color:#cdcd00">const</span><span style="color:#39c">&amp;</span> foo) {
        <span style="color:#cdcd00">return</span> (foo.<span style="color:#39c">*</span>kMemPtr)();
    }
};
<span style="color:#000080">// Friend (re-)declaration.
</span><span style="color:#000080"></span><span style="color:#00cd00">int</span> invoke_private_Foo_bar(Foo <span style="color:#cdcd00">const</span><span style="color:#39c">&amp;</span> foo);

<span style="color:#cdcd00">template</span> <span style="color:#39c">&lt;&gt;</span>
<span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">AccessPrivate</span><span style="color:#39c">&lt;&amp;</span>Foo<span style="color:#39c">::</span>x<span style="color:#39c">&gt;::</span>Delegate {
    <span style="color:#000080">// (Injected) friend definition.
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">friend</span> <span style="color:#00cd00">int</span><span style="color:#39c">&amp;</span> access_private_Foo_x(Foo<span style="color:#39c">&amp;</span> foo) {
        <span style="color:#cdcd00">return</span> foo.<span style="color:#39c">*</span>kMemPtr;
    }
};
<span style="color:#000080">// Friend (re-)declaration.
</span><span style="color:#000080"></span><span style="color:#00cd00">int</span><span style="color:#39c">&amp;</span> access_private_Foo_x(Foo<span style="color:#39c">&amp;</span> foo);
</code></pre></div><h3 id="dangers-will-robinson">Dangers, Will Robinson?</h3>
<p>Even if this explicit specialization is placed in a header, it is ODR-safe as an explicit specialization that defines a templated class is no different than a definition of non-templated class, and both fall under <a href="https://timsong-cpp.github.io/cppwp/n4861/basic.def.odr#13">[basic.def.odr]/13</a> in that they may have more than one definition in more than one TU, as long as the definitions are the same. This means we needn&rsquo;t apply the TU-unique dummy type template parameter tag that we had to use for the C++17 approach of explicit instantiation definitions. Moreover, we are safe against the dangers of violating <a href="https://eel.is/c++draft/temp.expl.spec#7">[temp.expl.spec]/7</a> [ <strong>emphasis</strong> mine]:</p>
<blockquote>
<p><strong>If</strong> a template, a member template or <strong>a member of a class template is explicitly specialized then that specialization shall be declared before the first use of that specialization that would cause an implicit instantiation to take place, in every translation unit in which such a use occurs; no diagnostic is required.</strong> If the program does not provide a definition for an explicit specialization and either the specialization is used in a way that would cause an implicit instantiation to take place or the member is a virtual member function, the program is ill-formed, no diagnostic required. An implicit instantiation is never generated for an explicit specialization that is declared but not defined.</p>
</blockquote>
<p>as any explicit specialization of <code>AccessPrivate::Delegate</code> is intended to ever only use a non-type template argument that may otherwise not be referred to—due to private access rules—and there is thus no risk that an implicit instantiation of such an specialization precedes the explicit specialization. Moreover, the sole purpose of each explicit specialization is to declare and define a uniquely named friend, whereas the specialization of the class itself is not intended to be used directly (say as an object or in an explicit instantiation definition).</p>
<p>Finally, as for any external linkage entity definition, we naturally mustn&rsquo;t provide <em>different</em> definitions for the same explicit specialization, or for the same (inline) friend function, in different TU:s. This is arguably <em>&ldquo;general ODR-sanity&rdquo;</em>, and it does not come with the same subtleness as that of the non-diagnosable and ill-formed NDR dangers of the explicit instantiation definition approach. Furthermore, as the definition of the accessor friend function is no longer depending on instantiation order in the sense that it captures a metaprogramming state, we are using a technique that does not fall under CWG issue 2118.</p>
<h3 id="circumvention-of-private-access-rules-by-means-of-explicit-specializations">Circumvention of private access rules by means of explicit specializations</h3>
<p>Thus, we have reached an alternative mechanism to that of the explicit instantiation definition approach, and we may reproduce the behaviour of the C++17 demo using our alternative approach:</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000080">// demo.cpp
</span><span style="color:#000080"></span><span style="color:#000080">#include</span> <span style="color:#000080">&lt;iostream&gt;</span><span style="color:#000080">
</span><span style="color:#000080">#include</span> <span style="color:#000080">&#34;access_private_of_foo_cpp20.h&#34;</span><span style="color:#000080">
</span><span style="color:#000080">#include</span> <span style="color:#000080">&#34;foo.h&#34;</span><span style="color:#000080">
</span><span style="color:#000080"></span>
<span style="color:#00cd00">void</span> demo() {
    Foo f{};

    <span style="color:#00cd00">int</span> hidden <span style="color:#39c">=</span> invoke_private_Foo_bar(f);  <span style="color:#000080">// int Foo::bar() const
</span><span style="color:#000080"></span>    std<span style="color:#39c">::</span>cout <span style="color:#39c">&lt;&lt;</span> hidden <span style="color:#39c">&lt;&lt;</span> <span style="color:#cd0000">&#34;</span><span style="color:#cd0000">\n</span><span style="color:#cd0000">&#34;</span>;  <span style="color:#000080">// 42
</span><span style="color:#000080"></span>
    access_private_Foo_x(f) <span style="color:#39c">=</span> <span style="color:#cd00cd">13</span>;
    hidden <span style="color:#39c">=</span> invoke_private_Foo_bar(f);  <span style="color:#000080">// int Foo::bar() const
</span><span style="color:#000080"></span>    std<span style="color:#39c">::</span>cout <span style="color:#39c">&lt;&lt;</span> hidden <span style="color:#39c">&lt;&lt;</span> <span style="color:#cd0000">&#34;</span><span style="color:#cd0000">\n</span><span style="color:#cd0000">&#34;</span>;  <span style="color:#000080">// 13
</span><span style="color:#000080"></span>}
</code></pre></div><p><a href="https://wandbox.org/permlink/sVJgppGUnD8EaWpp">Demo</a>.</p>
<h3 id="setting-up-a-simple-macro-api-lib">Setting up a simple macro API lib</h3>
<p>We&rsquo;ll conclude this post with setting up a small header-only lib of macros, used as a utility to apply the new C++20 approach as above without bothering about the details. Possibly someone can find this lib useful for, say, injection testing. As this post has become quite long-winding already, we&rsquo;ll settle for writing a macro API only for the simpler case of accessing private data members, whilst leaving the case of invokers for private members functions for a later time.</p>
<p>We may expand the <code>accessprivate.h</code> header above with the addition of a (beautifully highlighted<sup id="fnref:8"><a href="#fn:8" class="footnote-ref" role="doc-noteref">8</a></sup>) accessor creator macro:</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000080">// accessprivate/accessprivate.h
</span><span style="color:#000080"></span><span style="color:#000080">#pragma once
</span><span style="color:#000080"></span>
<span style="color:#cdcd00">namespace</span> accessprivate {
<span style="color:#cdcd00">template</span> <span style="color:#39c">&lt;</span><span style="color:#cdcd00">auto</span> mem_ptr<span style="color:#39c">&gt;</span>
<span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">AccessPrivate</span>
{
    <span style="color:#000080">// kMemPtr is intended to be either a pointer to a private
</span><span style="color:#000080"></span>    <span style="color:#000080">// member function or pointer to a private data member.
</span><span style="color:#000080"></span>    <span style="color:#cdcd00">static</span> <span style="color:#cdcd00">constexpr</span> <span style="color:#cdcd00">auto</span> kMemPtr <span style="color:#39c">=</span> mem_ptr;
    <span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">Delegate</span>;  <span style="color:#000080">// Define only in explicit specializations.
</span><span style="color:#000080"></span>};

}  <span style="color:#000080">// namespace accessprivate
</span><span style="color:#000080"></span>
<span style="color:#000080">// DEFINE_ACCESSOR(&lt;qualified class name&gt;, &lt;class data member&gt;)
</span><span style="color:#000080">//
</span><span style="color:#000080">// Example usage:
</span><span style="color:#000080">//   DEFINE_ACCESSOR(foo::Foo, x)
</span><span style="color:#000080">//
</span><span style="color:#000080">// Defines:
</span><span style="color:#000080">//   auto&amp; accessprivate::get_x(foo::Foo&amp;)
</span><span style="color:#000080"></span><span style="color:#000080">#define DEFINE_ACCESSOR(qualified_class_name, class_data_member)\
</span><span style="color:#000080">namespace accessprivate {\
</span><span style="color:#000080">template &lt;&gt;\
</span><span style="color:#000080">struct AccessPrivate&lt;&amp;qualified_class_name::class_data_member&gt;::Delegate {\
</span><span style="color:#000080">    friend auto&amp; get_##class_data_member(\
</span><span style="color:#000080">        qualified_class_name&amp; obj) { return obj.*kMemPtr; }\
</span><span style="color:#000080">};\
</span><span style="color:#000080">auto&amp; get_##class_data_member(qualified_class_name&amp; obj);\
</span><span style="color:#000080">}
</span></code></pre></div><p>which we may use as follows:</p>
<div class="highlight"><pre style="color:#ccc;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#000080">#include</span> <span style="color:#000080">&lt;iostream&gt;</span><span style="color:#000080">
</span><span style="color:#000080">#include</span> <span style="color:#000080">&#34;accessprivate/accessprivate.h&#34;</span><span style="color:#000080">
</span><span style="color:#000080"></span>
<span style="color:#cdcd00">namespace</span> bar {

<span style="color:#cdcd00">struct</span> <span style="color:#00cdcd">Bar</span> {
    <span style="color:#00cd00">int</span> getX() <span style="color:#cdcd00">const</span> { <span style="color:#cdcd00">return</span> x; }
    <span style="color:#00cd00">int</span> getY() <span style="color:#cdcd00">const</span> { <span style="color:#cdcd00">return</span> y; }
<span style="color:#cdcd00">private</span><span style="color:#39c">:</span>
    <span style="color:#00cd00">int</span> x{<span style="color:#cd00cd">42</span>};
    <span style="color:#00cd00">int</span> y{<span style="color:#cd00cd">88</span>};
};

}  <span style="color:#000080">// namespace bar
</span><span style="color:#000080"></span>
DEFINE_ACCESSOR(bar<span style="color:#39c">::</span>Bar, x)
<span style="color:#000080">// -&gt; accessprivate::get_x(Bar&amp;)
</span><span style="color:#000080"></span>DEFINE_ACCESSOR(bar<span style="color:#39c">::</span>Bar, y)
<span style="color:#000080">// -&gt; accessprivate::get_y(Bar&amp;)
</span><span style="color:#000080"></span>
<span style="color:#00cd00">void</span> demo() {
    bar<span style="color:#39c">::</span>Bar b{};
    accessprivate<span style="color:#39c">::</span>get_x(b) <span style="color:#39c">=</span> <span style="color:#cd00cd">13</span>;
    accessprivate<span style="color:#39c">::</span>get_y(b) <span style="color:#39c">=</span> <span style="color:#cd00cd">33</span>;
    std<span style="color:#39c">::</span>cout <span style="color:#39c">&lt;&lt;</span> b.getX() <span style="color:#39c">&lt;&lt;</span> <span style="color:#cd0000">&#34; &#34;</span> <span style="color:#39c">&lt;&lt;</span> b.getY();  <span style="color:#000080">// 13 33
</span><span style="color:#000080"></span>}
</code></pre></div><p><a href="https://wandbox.org/permlink/IGPP47w3OFUMKo6x">Demo</a>.</p>
<p>The lib has been published at <a href="https://github.com/dfrib/accessprivate">dfrib / accessprivate</a> at GitHub, and we may return to it in a future post, to have a look at whether we can expand it to provide macro &ldquo;overloads&rdquo; (delegating, per se) for invoking (non-overloaded) private member functions with a various number of function arguments.</p>
<p>We may also note that <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2017/p0692r1.html">P0692R1</a> points out that for the particular case of explicit specializations, the mechanism introduced by the paper is already implemented (non-documented) by all compilers that the authors of the paper had the chance to try out:</p>
<blockquote>
<p>It is important to note that even though the above specialization of trait is not allowed according to the standard, it <strong>builds with all compilers that were tested</strong>, including various versions of gcc, clang, icc, and msvc. Already, for the sake of standardizing existing practice, one might argue that this should be allowed.</p>
</blockquote>
<p>meaning that the <a href="https://github.com/dfrib/accessprivate">accessprivate</a> lib will most likely work with most compilers also in C++17, even if it is, strictly, non-conformant in C++17.</p>
<h3 id="recalling-the-disclaimer">Recalling the disclaimer</h3>
<p>Finally, before wrapping up, we&rsquo;ll re-visit the disclaimer above, adding a final reminder that the technique above should not be used in production code! Even if the technique results in well-formed code, a production code &ldquo;use case&rdquo; for this mechanism is likely either misunderstood, a code smell, or an <a href="https://en.wikipedia.org/wiki/XY%5Fproblem">XY problem</a>.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>Thanks to Christian von Schultz for proofreading the article.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>The original blog articles are unfortunately no longer reachable, but the related <a href="https://groups.google.com/a/isocpp.org/g/std-discussion/c/M6aJMH%5FewoM/">std-dicussion thread</a> pointed out some possibly flaws with the implementation which were never (at least publically) addressed. <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>Blog posts <a href="http://bloglitb.blogspot.com/2010/07/access-to-private-members-thats-easy.html"><em>Access to private members. That’s easy!</em></a> and <a href="http://bloglitb.blogspot.com/2011/12/access-to-private-members-safer.html"><em>Access to private members: Safer nastiness</em></a>, posted in 2010 and 2011, respectively. <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>Were I to speculate, this is not really any kind of high-priority (if even at all an) issue for the C++ language as such, but rather a dark corner that should <em>ideally</em> not exist for the <em>Machiavellistic</em> language lawyers out there to abuse; a paraphrasing of <a href="http://www.gotw.ca/gotw/076.htm">the words of Herb</a>, on the topic of the existence of mechanisms in the language that <em>can</em> be abused: <em>&ldquo;This isn&rsquo;t actually a problem. The issue here is of protecting against Murphy vs. protecting against Machiavelli&hellip; that is, protecting against accidental misuse (which the language does very well) vs. protecting against deliberate abuse (which is effectively impossible).&quot;</em> <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>The meaning of what is a metaprogramming state is not exlicitly explained in CWG 2118, and it is a non-normative term, but it arguably refers to capturing a state of translation, in the sense that one attempts to (say, within a TU), capture which specialization that was instantiated not only <em>first</em> (and only), but beyond that. In this article <em>&ldquo;instantiated second&rdquo;</em> would be ill-formed, but in Roséen&rsquo;s article (IIRC) injected templated friends were used to use the (afaik non-specified) <em>relative</em> order of instantiations of different specializations within a single TU. This was most likely non-conformant, but the major compilers (at the time) seemingly implemented instantiation order in a way that allowed the constexpr counter to work as intended. <a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p><a href="https://timsong-cpp.github.io/cppwp/n4659/">N4659</a>: : March 2017 post-Kona working draft/C++17 DIS. <a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p>As per <a href="https://timsong-cpp.github.io/cppwp/n4659/basic.lookup.argdep#4">[basic.lookup.argdep]/4</a> a hidden friend (defined at its friend declaration without a matching declaration at namespace scope) can be found via ADL on the class type in which is has defined, but this is not of interest for the use cases of this blog post. <a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7" role="doc-endnote">
<p><a href="https://timsong-cpp.github.io/cppwp/n4861/">N4861</a>: March 2020 post-Prague working draft/C++20 DIS. <a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:8" role="doc-endnote">
<p>I&rsquo;ll intentiationally leave the entirely broken syntax highlighting of the macro as a subtle reminder of that macros are, generally, evil. <a href="#fnref:8" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

			

			
			
			
			
	        
	        
	        
	        
	        
	        
			
			    

                
				
				

			
				<div class="paging">
					<span class="paging-label">More Reading</span>

					

                    
					<div class="paging-newer">
						<span class="dark-red">Older</span><span class="decorative-marker">//</span>
						<a class="paging-link" href="https://dfrib.github.io/typedef-where-alias-decl-cannot/">A typedef for when an alias declaration cannot</a>
		            </div>
		            
	            </div>
                    

                    
                    
          </section>
          
          	<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "dfrib" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          
        
      <div class="footer">
	<hr class="thin" />
	<div class="pure-menu pure-menu-horizontal pure-menu-open">
		<ul class="footer-menu">
		
		</ul>
	</div>

	<p>David Friberg &copy 2020</p>
	<p>Published with <a href="https://gohugo.io">Hugo</a> using a modified <a href="https://github.com/tmaiaroto/hugo-redlounge">Redlounge</a></p>
</div>

    </div>
  </div>
	

	

  
</body>
</html>
